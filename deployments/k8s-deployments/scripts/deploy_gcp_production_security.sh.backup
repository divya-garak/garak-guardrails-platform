#!/bin/bash

# =============================================================================
# GCP Production Security Deployment Script
# Deploy NeMo Guardrails with comprehensive security configurations
# =============================================================================

set -e  # Exit on any error
set -u  # Exit on undefined variables

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

# Logging function
log() {
    echo -e "${BLUE}[$(date +'%H:%M:%S')]${NC} $1"
}

error() {
    echo -e "${RED}[ERROR]${NC} $1" >&2
    exit 1
}

success() {
    echo -e "${GREEN}[SUCCESS]${NC} $1"
}

warning() {
    echo -e "${YELLOW}[WARNING]${NC} $1"
}

# Configuration
PROJECT_ID=${GCP_PROJECT_ID:-"garak-shield"}
REGION=${GCP_REGION:-"us-central1"}
ZONE=${GCP_ZONE:-"us-central1-a"}
CLUSTER_NAME="nemo-guardrails-production"
SERVICE_NAME="nemo-guardrails-secure"
NAMESPACE="default"
DOMAIN="api.garaksecurity.com"
IMAGE_NAME="nemo-guardrails-secure"
OPENAI_API_KEY="[REDACTED_API_KEY]"
REDIS_PASSWORD="redis123"

log "üöÄ Starting GCP Production Security Deployment"
log "Project: $PROJECT_ID"
log "Region: $REGION"
log "Cluster: $CLUSTER_NAME"

# =============================================================================
# STEP 1: Setup GCP Environment
# =============================================================================

log "üìã Step 1: Setting up GCP environment..."

# Set project
gcloud config set project $PROJECT_ID

# Enable required APIs
log "Enabling required GCP APIs..."
gcloud services enable container.googleapis.com
gcloud services enable compute.googleapis.com
gcloud services enable storage.googleapis.com

# =============================================================================
# STEP 2: Build and Push Docker Image
# =============================================================================

log "üê≥ Step 2: Building and pushing Docker image with working NeMo configuration..."

# Build the Docker image
docker build -f Dockerfile.full -t gcr.io/$PROJECT_ID/$IMAGE_NAME:latest .

# Push to GCP Container Registry  
docker push gcr.io/$PROJECT_ID/$IMAGE_NAME:latest

success "‚úÖ Docker image built and pushed to gcr.io/$PROJECT_ID/$IMAGE_NAME:latest"

# =============================================================================
# STEP 3: Create/Update GKE Cluster
# =============================================================================

log "üèóÔ∏è  Step 3: Setting up GKE cluster..."

# Check if cluster exists
if gcloud container clusters describe $CLUSTER_NAME --region=$REGION >/dev/null 2>&1; then
    log "Cluster $CLUSTER_NAME already exists, getting credentials..."
    gcloud container clusters get-credentials $CLUSTER_NAME --region=$REGION
else
    log "Creating new GKE cluster $CLUSTER_NAME..."
    gcloud container clusters create $CLUSTER_NAME \
        --region=$REGION \
        --num-nodes=3 \
        --enable-autoscaling \
        --min-nodes=2 \
        --max-nodes=10 \
        --machine-type=e2-standard-4 \
        --disk-size=50GB \
        --enable-autorepair \
        --enable-autoupgrade \
        --enable-network-policy \
        --enable-ip-alias \
        --enable-shielded-nodes \
        --shielded-secure-boot \
        --shielded-integrity-monitoring
fi

# =============================================================================
# STEP 4: Create Kubernetes Resources
# =============================================================================

log "‚öôÔ∏è  Step 4: Creating Kubernetes resources..."

# Create namespace if it doesn't exist
kubectl create namespace $NAMESPACE --dry-run=client -o yaml | kubectl apply -f -

# Secrets are hardcoded in environment variables - no Kubernetes secrets needed
log "Using hardcoded secrets in deployment..."

# =============================================================================
# STEP 5: Deploy Redis for Threading Support
# =============================================================================

log "üóÑÔ∏è  Step 5: Deploying Redis for threading support..."

cat <<EOF | kubectl apply -f -
apiVersion: apps/v1
kind: Deployment
metadata:
  name: redis
  namespace: $NAMESPACE
  labels:
    app: redis
spec:
  replicas: 1
  selector:
    matchLabels:
      app: redis
  template:
    metadata:
      labels:
        app: redis
    spec:
      containers:
      - name: redis
        image: redis:7-alpine
        ports:
        - containerPort: 6379
        env:
        - name: REDIS_PASSWORD
          value: "$REDIS_PASSWORD"
        command: ["redis-server"]
        args: ["--requirepass", "$REDIS_PASSWORD", "--maxmemory", "512mb", "--maxmemory-policy", "allkeys-lru"]
        resources:
          requests:
            cpu: 100m
            memory: 256Mi
          limits:
            cpu: 500m
            memory: 512Mi
        livenessProbe:
          exec:
            command:
            - redis-cli
            - --no-auth-warning
            - -a
            - "$REDIS_PASSWORD"
            - ping
          initialDelaySeconds: 30
          periodSeconds: 10
        readinessProbe:
          exec:
            command:
            - redis-cli
            - --no-auth-warning
            - -a
            - "$REDIS_PASSWORD"
            - ping
          initialDelaySeconds: 5
          periodSeconds: 5
---
apiVersion: v1
kind: Service
metadata:
  name: redis-service
  namespace: $NAMESPACE
spec:
  selector:
    app: redis
  ports:
  - port: 6379
    targetPort: 6379
  type: ClusterIP
EOF

# =============================================================================
# STEP 6: Deploy NeMo Guardrails with Security Configurations
# =============================================================================

log "üõ°Ô∏è  Step 6: Deploying NeMo Guardrails with security configurations..."

cat <<EOF | kubectl apply -f -
apiVersion: apps/v1
kind: Deployment
metadata:
  name: $SERVICE_NAME
  namespace: $NAMESPACE
  labels:
    app: $SERVICE_NAME
    version: v1.0.0
    tier: production
spec:
  replicas: 3
  selector:
    matchLabels:
      app: $SERVICE_NAME
  template:
    metadata:
      labels:
        app: $SERVICE_NAME
        version: v1.0.0
        tier: production
    spec:
      containers:
      - name: nemo-guardrails
        image: gcr.io/$PROJECT_ID/$IMAGE_NAME:latest
        ports:
        - containerPort: 8000
          name: http
        env:
        - name: OPENAI_API_KEY
          value: "$OPENAI_API_KEY"
        - name: NEMO_GUARDRAILS_SERVER_ENABLE_CORS
          value: "true"
        - name: NEMO_GUARDRAILS_SERVER_ALLOWED_ORIGINS
          value: "https://dashboard.garaksecurity.com,https://api.garaksecurity.com"
        - name: DATASTORE_TYPE
          value: "redis"
        - name: REDIS_HOST
          value: "redis-service"
        - name: REDIS_PORT
          value: "6379"
        - name: REDIS_DB
          value: "0"
        - name: REDIS_PASSWORD
          value: "$REDIS_PASSWORD"
        - name: ENABLE_SECURITY_MONITORING
          value: "true"
        - name: MAX_THREAD_HISTORY
          value: "100"
        - name: THREAD_TTL_HOURS
          value: "24"
        
        resources:
          requests:
            cpu: 500m
            memory: 2Gi
          limits:
            cpu: 2000m
            memory: 4Gi
            
        livenessProbe:
          httpGet:
            path: /health
            port: 8000
          initialDelaySeconds: 120
          periodSeconds: 30
          timeoutSeconds: 10
          failureThreshold: 3
          
        readinessProbe:
          httpGet:
            path: /health
            port: 8000
          initialDelaySeconds: 60
          periodSeconds: 10
          timeoutSeconds: 5
          failureThreshold: 2
          
        securityContext:
          runAsNonRoot: true
          runAsUser: 1000
          readOnlyRootFilesystem: false
          allowPrivilegeEscalation: false
          capabilities:
            drop:
            - ALL
      
      restartPolicy: Always
      
---
apiVersion: v1
kind: Service
metadata:
  name: ${SERVICE_NAME}-service
  namespace: $NAMESPACE
  labels:
    app: $SERVICE_NAME
spec:
  selector:
    app: $SERVICE_NAME
  ports:
  - name: http
    port: 80
    targetPort: 8000
    protocol: TCP
  type: LoadBalancer
  
---
apiVersion: autoscaling/v2
kind: HorizontalPodAutoscaler
metadata:
  name: ${SERVICE_NAME}-hpa
  namespace: $NAMESPACE
spec:
  scaleTargetRef:
    apiVersion: apps/v1
    kind: Deployment
    name: $SERVICE_NAME
  minReplicas: 2
  maxReplicas: 10
  metrics:
  - type: Resource
    resource:
      name: cpu
      target:
        type: Utilization
        averageUtilization: 70
  - type: Resource
    resource:
      name: memory
      target:
        type: Utilization
        averageUtilization: 80
EOF

# =============================================================================
# STEP 7: Wait for Deployment and Get External IP
# =============================================================================

log "‚è≥ Step 7: Waiting for deployment to be ready..."

# Wait for deployment to be ready
kubectl wait --for=condition=available deployment/$SERVICE_NAME --namespace=$NAMESPACE --timeout=600s

# Wait for service to get external IP
log "Waiting for LoadBalancer to get external IP..."
EXTERNAL_IP=""
while [ -z "$EXTERNAL_IP" ]; do
    echo "Waiting for external IP..."
    EXTERNAL_IP=$(kubectl get service ${SERVICE_NAME}-service --namespace=$NAMESPACE -o jsonpath='{.status.loadBalancer.ingress[0].ip}' 2>/dev/null || echo "")
    if [ -z "$EXTERNAL_IP" ]; then
        sleep 10
    fi
done

success "üéâ Deployment completed successfully!"
log "External IP: $EXTERNAL_IP"
log "Health Check: http://$EXTERNAL_IP/"
log "API Endpoint: http://$EXTERNAL_IP/v1/chat/completions"

# =============================================================================
# STEP 8: Basic Health Check
# =============================================================================

log "üè• Step 8: Running basic health check..."

# Wait a bit for the service to be fully ready
sleep 30

# Test health endpoint
if curl -f -s "http://$EXTERNAL_IP/" > /dev/null; then
    success "‚úÖ Health check passed!"
    
    # Show health response
    log "Health response:"
    curl -s "http://$EXTERNAL_IP/" | jq '.' || echo "Response received but not JSON"
    
else
    warning "‚ö†Ô∏è  Health check failed, but deployment completed. Service may still be starting up."
fi

# =============================================================================
# FINAL OUTPUT
# =============================================================================

echo ""
echo "=============================================================================="
echo "üöÄ GCP PRODUCTION SECURITY DEPLOYMENT COMPLETE"
echo "=============================================================================="
echo ""
echo "üìã Deployment Summary:"
echo "   Project: $PROJECT_ID"
echo "   Region: $REGION"
echo "   Cluster: $CLUSTER_NAME" 
echo "   Service: $SERVICE_NAME"
echo "   External IP: $EXTERNAL_IP"
echo ""
echo "üîó Endpoints:"
echo "   Health Check: http://$EXTERNAL_IP/"
echo "   Detailed Health: http://$EXTERNAL_IP/health"
echo "   Configurations: http://$EXTERNAL_IP/v1/rails/configs"
echo "   Chat API: http://$EXTERNAL_IP/v1/chat/completions"
echo ""
echo "üõ°Ô∏è Security Configurations Deployed:"
echo "   - basic_security: Essential protection"
echo "   - production_security: Comprehensive security (default)"
echo "   - maximum_security: Enterprise-grade protection"
echo ""
echo "üîß Features Available:"
echo "   ‚úÖ Jailbreak protection (multi-layer)"
echo "   ‚úÖ Content safety filtering"
echo "   ‚úÖ Injection protection"
echo "   ‚úÖ Threading support (Redis-backed)"
echo "   ‚úÖ Streaming responses (SSE format)"
echo "   ‚úÖ Enhanced health endpoints"
echo "   ‚úÖ Production monitoring"
echo ""
echo "üìù Next Steps:"
echo "   1. Update your DNS to point $DOMAIN to $EXTERNAL_IP"
echo "   2. Configure SSL certificate for HTTPS"
echo "   3. Run comprehensive tests: python dashboard_tests/test_production_security_deployment.py"
echo "   4. Monitor deployment: kubectl get pods -n $NAMESPACE"
echo ""
echo "üéâ Your secure NeMo Guardrails deployment is ready!"
echo "üåê Target domain: https://$DOMAIN"
echo "=============================================================================="